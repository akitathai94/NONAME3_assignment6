/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. pcl2.jj */
/*@egen*/options{
    IGNORE_CASE=true;
                                               
                                                            
               
                 
    //DEBUG_PARSER=true;
}

PARSER_BEGIN(PclParser)
package wci.frontend;

import java.util.ArrayList;
import java.io.*;

import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.backend.*;
import wci.util.*;

import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class PclParser/*@bgen(jjtree)*/implements PclParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTPclParserState jjtree = new JJTPclParserState();

/*@egen*/
    private static final String SOURCE_SUFFIX = ".pcl";
    private static final String OUTPUT_SUFFIX = ".j";

    private static SymTabStack symTabStack;
    private static SymTabEntry programId;

    public static void main(String[] args)
        throws Exception
    {
    	// Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);

        // Process the source file path which ends in .pcl
        // and create the output file path which ends in .j
        String sourceFilePath = args[0];
        int truncatedLength = sourceFilePath.length() - SOURCE_SUFFIX.length();
        int suffixIndex = sourceFilePath.lastIndexOf(SOURCE_SUFFIX);
        String objectFilePath = (suffixIndex == truncatedLength)
            ? sourceFilePath.substring(0, truncatedLength) + OUTPUT_SUFFIX
            : sourceFilePath + OUTPUT_SUFFIX;

        // Parse a Pcl program.
        Reader    reader = new FileReader(sourceFilePath);
        PclParser parser = new PclParser(reader);
        SimpleNode rootNode = parser.program();

        // Print the cross-reference table.
        CrossReferencer crossReferencer = new CrossReferencer();
        crossReferencer.print(symTabStack);

        // Visit the parse tree nodes to decorate them with type information.
        TypeSetterVisitor typeVisitor = new TypeSetterVisitor();
        rootNode.jjtAccept(typeVisitor, null);

        // Create and initialize the ICode wrapper for the parse tree.
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);
        
        // Print the parse tree.
        ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
        treePrinter.print(symTabStack);

        // Create the compiler backend and generate code.
        Backend backend = BackendFactory.createBackend("compile");
        backend.process(iCode, symTabStack, objectFilePath);
    }
}
PARSER_END(PclParser)

SKIP: {
    " " | "\r" | "\t" | "\n"
  | <COMMENT : "{"(~["{"])*"}">
}

TOKEN: { /* Reserved words */
    <BEGIN     : "BEGIN">
  | <END       : "END">
  | <PROGRAM   : "PROGRAM">
  | <VAR       : "VAR">
  | <WRITELN   : "writeln" >
  | < IF	   : "if" >
  | < ELSE     : "else" >
  | < DO       : "do" >
  | < WHILE    : "while" >
}

TOKEN: /* Special symbols */
{
    <COLON        : ":">
  | <EQUAL		  : "=">
  | <COMMA        : ",">
  | <DOT          : ".">
  | <SEMICOLON    : ";">
  | <PLUS         : "+">
  | <MINUS        : "-">
  | <STAR         : "*">
  | <SLASH        : "/">
  | <QUOTE        : "'">
  | < OPAREN 	  : "(" >
  | < CPAREN      : ")" >
}

TOKEN: { /* Identifiers, strings, and numbers */
    <IDENTIFIER : <LETTER>(<LETTER>|<DIGIT>)*>
  |< STRING_LITERAL: "\""
    					((~["\"","\\","\n","\r"])
    			|  ("\\" (["n","t","b","r","f","\\","'","\""]
    			| ["0" -"7"] (["0"-"7"] )?
    			| ["0" - "3"] ["0"-"7"] ["0"-"7"]
    	)
    	)
   )*
   "\""
   >
    	  | <SIMPLE_EXPRESSION  : (<GT >|<GE >|<LT >|<LE >|<EQ >|<NTE >) >					  
  | < CHAR   :< QUOTE >(< LETTER >|< DIGIT >)< QUOTE > >
  | <INTEGER : (<UNSIGNED_NUMBER>|< SIGNED_NUMBER>) >
  | <REAL    : <WHOLE><FRACTION><EXPONENT>
             | <WHOLE><FRACTION>
             | <WHOLE><EXPONENT>>
  | <#GT : ">" >
  | <#GE : ">=" >
  | <#LT : "<" >
  | <#LE :"<=" >
  | <#EQ :"==" >
  | <#NTE:"!=" > 
  | <#LETTER : ["a"-"z", "A"-"Z"]>
  | <#DIGIT  : ["0"-"9"]>
  | <#SIGN   : ["+", "-"]>
  | < #SIGNED_NUMBER : < SIGN >(< DIGIT >)+ >
  | <#UNSIGNED_NUMBER : (<DIGIT>)+>
  | <#WHOLE           : <UNSIGNED_NUMBER>>
  | <#FRACTION        : "." <UNSIGNED_NUMBER>>
  | <#EXPONENT        : "E"(<SIGN>)?<UNSIGNED_NUMBER>>
}

TOKEN: { /*	Error token */
    <ERROR : ~["\r", "\n"]>
}

SimpleNode program()       : {SimpleNode rootNode;}
{
    try {
        programHeader()
        rootNode = block()
        <DOT>
        <EOF> {
            return rootNode;
        }
    }
    catch (ParseException ex) {
        handleError(ex);
        return null;
    }
}

void programHeader()       : {}
{
    <PROGRAM>
    <IDENTIFIER> {
        programId = symTabStack.enterLocal(token.image);
        programId.setDefinition(DefinitionImpl.PROGRAM);
        programId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
        symTabStack.setProgramId(programId);
    }
    <SEMICOLON>
}
SimpleNode block()       : {SimpleNode rootNode;}
{
    variableDeclarations()
    rootNode = compoundStatement() {
        return rootNode;
    }
}

void variableDeclarations()       : {ArrayList<SymTabEntry> variableList;
	                                 int index = 0;}
{
    <VAR>
    (
        <IDENTIFIER> {
            variableList = new ArrayList<SymTabEntry>();
            processVariableDecl(token, index++, variableList);
        }
        (
            <COMMA>
            <IDENTIFIER> {
                processVariableDecl(token, index++, variableList);
            }
        )*
        <COLON>
        <IDENTIFIER> {
            SymTabEntry typeId = symTabStack.lookup(token.image);
            typeId.appendLineNumber(token.beginLine);
            TypeSpec type = typeId.getTypeSpec();

            for (SymTabEntry variableId : variableList) {
                variableId.setTypeSpec(type);
            }
        }
        <SEMICOLON>
    )+ {
        programId.setAttribute(ROUTINE_LOCALS_COUNT, index);
    }
}

void statement()       : {}
{
  	  ifStatement()
  	| dowhileStatement()
    | assignmentStatement()
    |  compoundStatement()
    
}

SimpleNode compoundStatement() : {/*@bgen(jjtree) compoundStatement */
  ASTcompoundStatement jjtn000 = new ASTcompoundStatement(JJTCOMPOUNDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) compoundStatement */
    try {
/*@egen*/
    <BEGIN>
    [
        statement()
        (
            <SEMICOLON>
            statement()
        )*
    ]
    <END>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void assignmentStatement() : {/*@bgen(jjtree) assignmentStatement */
  ASTassignmentStatement jjtn000 = new ASTassignmentStatement(JJTASSIGNMENTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) assignmentStatement */
    try {
/*@egen*/
    variable() {
        SymTabEntry variableId = symTabStack.lookup(token.image);
        variableId.appendLineNumber(token.beginLine);
    }
    <EQUAL>
    expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void simpleExpressionStatement() : {/*@bgen(jjtree) simpleExpressionStatement */
  ASTsimpleExpressionStatement jjtn000 = new ASTsimpleExpressionStatement(JJTSIMPLEEXPRESSIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) simpleExpressionStatement */
  try {
/*@egen*/
  <OPAREN >  variable() {
        SymTabEntry variableId = symTabStack.lookup(token.image);
        variableId.appendLineNumber(token.beginLine);
    }
    <SIMPLE_EXPRESSION > variable() < CPAREN >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void ifStatement() : {/*@bgen(jjtree) ifStatement */
  ASTifStatement jjtn000 = new ASTifStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifStatement */
  try {
/*@egen*/
  < IF > simpleExpressionStatement() assignmentStatement()< SEMICOLON >
    < ELSE > assignmentStatement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void dowhileStatement() : {/*@bgen(jjtree) dowhileStatement */
  ASTdowhileStatement jjtn000 = new ASTdowhileStatement(JJTDOWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) dowhileStatement */
  try {
/*@egen*/
  < DO ><OPAREN >(statement()< SEMICOLON >)*
  < CPAREN ><WHILE >simpleExpressionStatement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void expression()       : {}
{
    term() (
        "+"/*@bgen(jjtree) #add( 2) */
            {
              ASTadd jjtn001 = new ASTadd(JJTADD);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ term()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/        
      | "-"/*@bgen(jjtree) #subtract( 2) */
            {
              ASTsubtract jjtn002 = new ASTsubtract(JJTSUBTRACT);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/ term()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
              }
            }
/*@egen*/             
    )*     
}

void term()       : {}
{
    factor() (
        "*"/*@bgen(jjtree) #multiply( 2) */
            {
              ASTmultiply jjtn001 = new ASTmultiply(JJTMULTIPLY);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ factor()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/             
      | "/"/*@bgen(jjtree) #divide( 2) */
            {
              ASTdivide jjtn002 = new ASTdivide(JJTDIVIDE);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/ factor()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
              }
            }
/*@egen*/           
    )*     
}

void factor()       : {}
{
    variable()
  | charConstant()
  | integerConstant()
  | realConstant()
}

void variable() : {/*@bgen(jjtree) variable */
  ASTvariable jjtn000 = new ASTvariable(JJTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) variable */
    try {
/*@egen*/
    <IDENTIFIER>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {
        SymTabEntry variableId = symTabStack.lookup(token.image);
        variableId.appendLineNumber(token.beginLine);
        TypeSpec type = variableId.getTypeSpec();
        jjtn000.setTypeSpec(type);
        jjtn000.setAttribute(ID, variableId);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void integerConstant() : {/*@bgen(jjtree) integerConstant */
  ASTintegerConstant jjtn000 = new ASTintegerConstant(JJTINTEGERCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) integerConstant */
    try {
/*@egen*/
    <INTEGER>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.integerType);
        jjtn000.setAttribute(VALUE, Integer.parseInt(token.image));
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void realConstant() : {/*@bgen(jjtree) realConstant */
  ASTrealConstant jjtn000 = new ASTrealConstant(JJTREALCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) realConstant */
    try {
/*@egen*/
    <REAL>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.realType);
        jjtn000.setAttribute(VALUE, Float.parseFloat(token.image));
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void charConstant() : {/*@bgen(jjtree) charConstant */
  ASTcharConstant jjtn000 = new ASTcharConstant(JJTCHARCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) charConstant */
        try {
/*@egen*/
  	< CHAR >/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {
  	  jjtn000.setTypeSpec(Predefined.charType);
  	  jjtn000.setAttribute(VALUE, (token.image));
  	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void Error()       : {}
{
    <ERROR>
}

JAVACODE
void processVariableDecl(Token token, int index,
                         ArrayList<SymTabEntry> variableList)      
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
    variableList.add(variableId);
}

JAVACODE
String handleError(ParseException ex)      
{
    Token token = ex.currentToken;
    System.out.println(ex.getMessage());

    do {
    	token = getNextToken();
    } while (token.kind != SEMICOLON);

	jjtree.popNode();
    return token.image;
}
